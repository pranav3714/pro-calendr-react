---
phase: 04-keyboard-navigation-accessibility
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/core/src/hooks/use-keyboard.ts
  - packages/core/src/components/Calendar.tsx
  - packages/core/src/components/CalendarBody.tsx
autonomous: true

must_haves:
  truths:
    - "Pressing T navigates to today, D/W/M switch to Day/Week/Month views when calendar is focused"
    - "Shortcuts only fire when focus is within the calendar root (not globally)"
    - "Shortcuts do not fire when focus is in INPUT, TEXTAREA, SELECT, or contentEditable elements"
    - "Enter/Space on a focused cell activates the event in that cell (triggers onEventClick) or confirms slot selection"
    - "Escape cancels active drag first, then clears selection, with priority chain"
    - "Focus lands on a sensible cell after view switch (matching the previously focused date or defaulting to first cell)"
    - "Calendar root has tabIndex={-1} for keyboard event bubbling"
  artifacts:
    - path: "packages/core/src/hooks/use-keyboard.ts"
      provides: "Full keyboard shortcut handler with view switching, activation, and escape chain"
      exports: ["useKeyboard"]
    - path: "packages/core/src/components/Calendar.tsx"
      provides: "Calendar root with tabIndex={-1} and onKeyDown wiring"
      contains: "tabIndex={-1}"
    - path: "packages/core/src/components/CalendarBody.tsx"
      provides: "Focus restoration on view switch"
      contains: "focus"
  key_links:
    - from: "packages/core/src/hooks/use-keyboard.ts"
      to: "packages/core/src/store/slices/interaction-slice.ts"
      via: "reads dragEngine.phase and selection to determine Escape behavior"
      pattern: "dragEngine|selection"
    - from: "packages/core/src/components/Calendar.tsx"
      to: "packages/core/src/hooks/use-keyboard.ts"
      via: "useKeyboard called in CalendarInner with rootRef"
      pattern: "useKeyboard"
    - from: "packages/core/src/components/CalendarBody.tsx"
      to: "packages/core/src/store/slices/interaction-slice.ts"
      via: "reads focusedDate for focus restoration target"
      pattern: "focusedDate"
---

<objective>
Rewrite the useKeyboard hook with view shortcuts (T/D/W/M), Enter/Space activation, Escape priority chain, and add focus restoration on view transitions.

Purpose: This completes the keyboard navigation experience. Users can switch views, activate events, cancel interactions, and maintain focus context when moving between views -- all without a mouse.

Output: Full keyboard shortcut system, Calendar root keyboard wiring, focus restoration on view switch.
</objective>

<execution_context>
@/home/blacksilver/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/blacksilver/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-keyboard-navigation-accessibility/04-RESEARCH.md
@.planning/phases/04-keyboard-navigation-accessibility/04-01-SUMMARY.md
@packages/core/src/hooks/use-keyboard.ts
@packages/core/src/components/Calendar.tsx
@packages/core/src/components/CalendarBody.tsx
@packages/core/src/store/slices/interaction-slice.ts
@packages/core/src/constants/keys.ts
@packages/core/src/types/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite useKeyboard hook with shortcuts, activation, and Escape chain</name>
  <files>
    packages/core/src/hooks/use-keyboard.ts
  </files>
  <action>
Completely rewrite `use-keyboard.ts` (currently a stub with a TODO comment).

**New API:**
```typescript
interface UseKeyboardOptions {
  rootRef: RefObject<HTMLElement | null>;
  config: KeyboardShortcutsConfig;
  setView: (view: CalendarViewType) => void;
  navigateDate: (dir: 'prev' | 'next' | 'today') => void;
  cancelDrag: () => void;
  setSelection: (sel: Selection | null) => void;
  getDragPhase: () => DragPhase;
  getSelection: () => Selection | null;
}

export function useKeyboard(options: UseKeyboardOptions): void
```

**Implementation:**
- Use `useEffect` to attach a `keydown` listener on `rootRef.current` (the calendar root element). NOT on `document`.
- Guard: If `!config.enabled`, return early (no listener attached).
- Inside the handler:
  1. **Input guard:** If `e.target` is INPUT, TEXTAREA, SELECT, or `isContentEditable`, return immediately. Use `(e.target as HTMLElement).tagName` check plus `(e.target as HTMLElement).isContentEditable` check.
  2. **Escape priority chain** (KBNV-04):
     - Check `getDragPhase()`. If `'pending'` or `'dragging'`, call `cancelDrag()` and return. The existing `useEventInteractions` also handles Escape via `document.addEventListener('keydown')` which fires first. But this is a safety net -- if the drag was already cancelled by the native handler, `getDragPhase()` will be `'idle'` and we skip.
     - Else check `getSelection()`. If non-null, call `setSelection(null)` and return.
     - Otherwise, Escape does nothing further.
  3. **View shortcuts** (KBNV-02, KBNV-08):
     - `KEYS.TODAY` ('t'): call `navigateDate('today')`
     - `KEYS.DAY_VIEW` ('d'): call `setView('day')`
     - `KEYS.WEEK_VIEW` ('w'): call `setView('week')`
     - `KEYS.MONTH_VIEW` ('m'): call `setView('month')`
  4. **Custom bindings:** If `config.customBindings` has a matching key, call it.
  5. For all handled keys, do NOT call `e.preventDefault()` for single-letter shortcuts (t/d/w/m) -- the input guard already filters out text inputs. But DO call `e.preventDefault()` for Escape to prevent any browser default.

**Use `getDragPhase` and `getSelection` as functions** (not reactive state) to avoid stale closure issues. These should read from `store.getState()` at call time. The caller (CalendarInner) will provide these via `useCalendarStore.getState` pattern or by wrapping store selectors in `useCallback`.

Actually, simpler approach: pass `store` reference and read inline:
```typescript
// In the handler:
const dragPhase = store.getState().dragEngine.phase;
const selection = store.getState().selection;
```
But the hook shouldn't take the raw store. Instead, use the options pattern above with getter functions. The CalendarInner component creates stable callbacks:
```typescript
const getDragPhase = useCallback(() => store.getState().dragEngine.phase, [store]);
```

**Options ref pattern:** Wrap the entire options object in a `useRef` (like `use-event-interactions.ts` does with `optionsRef`) to avoid recreating the event listener on every render. Only `rootRef` and `config.enabled` should be in the `useEffect` deps.

**Key constant usage:** Use `KEYS.ESCAPE`, `KEYS.TODAY`, `KEYS.DAY_VIEW`, `KEYS.WEEK_VIEW`, `KEYS.MONTH_VIEW` from `constants/keys.ts`.
  </action>
  <verify>
    Run `pnpm typecheck` -- no type errors.
    Run `pnpm lint` -- no lint violations.
    Verify use-keyboard.ts exports `useKeyboard` with the full options signature.
    Verify Escape handling checks drag phase before selection.
    Verify input guard prevents shortcuts in INPUT/TEXTAREA/SELECT elements.
  </verify>
  <done>
    useKeyboard hook handles: T (today), D/W/M (view switch) scoped to calendar focus; Escape with drag-first priority chain; input element guard. Attached to calendar root element (not document). Uses options ref pattern for stable closures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire useKeyboard into Calendar root and add focus restoration in CalendarBody</name>
  <files>
    packages/core/src/components/Calendar.tsx
    packages/core/src/components/CalendarBody.tsx
  </files>
  <action>
**1. Calendar.tsx (CalendarInner):**
- Add a `rootRef = useRef<HTMLDivElement>(null)` for the calendar root div
- Add `tabIndex={-1}` to the root div (makes it focusable for keyboard event bubbling but not in the tab order)
- Add `ref={rootRef}` to the root div
- Import and call `useKeyboard` with:
  ```typescript
  useKeyboard({
    rootRef,
    config: { enabled: true }, // Default to enabled; could come from props in future
    setView,
    navigateDate,
    cancelDrag: useCalendarStore((s) => s.cancelDrag),
    setSelection: useCalendarStore((s) => s.setSelection),
    getDragPhase: () => store.getState().dragEngine.phase,
    getSelection: () => store.getState().selection,
  });
  ```

  For `getDragPhase` and `getSelection`, we need the raw store. Access it via `useContext(CalendarStoreContext)` or, since CalendarInner is already inside CalendarProvider, use a pattern to get the store. Looking at the existing code, `useCalendarStore` requires a selector. To get the raw store for `.getState()`, we need `CalendarStoreContext`. Import `CalendarStoreContext` from `./CalendarContext` and use `const store = useContext(CalendarStoreContext)`.

  Wait -- check if `CalendarStoreContext` is exported. If not, create stable getter callbacks using selectors:
  ```typescript
  const cancelDrag = useCalendarStore((s) => s.cancelDrag);
  const setSelection = useCalendarStore((s) => s.setSelection);
  ```
  For the getters, use a ref-based approach:
  ```typescript
  const dragPhaseRef = useRef<DragPhase>('idle');
  const selectionRef = useRef<Selection | null>(null);
  // Subscribe separately
  const dragPhase = useCalendarStore((s) => s.dragEngine.phase);
  const selection = useCalendarStore((s) => s.selection);
  dragPhaseRef.current = dragPhase;
  selectionRef.current = selection;

  // Pass to useKeyboard:
  getDragPhase: () => dragPhaseRef.current,
  getSelection: () => selectionRef.current,
  ```

- Remove the old `useKeyboard` import if it existed (currently not called in CalendarInner)

**2. CalendarBody.tsx:**
- Add `useRef<HTMLDivElement>(null)` for the body container
- Read `focusedDate` from the store: `const focusedDate = useCalendarStore((s) => s.focusedDate)`
- Add a `useEffect` that fires when `currentView` changes:
  ```typescript
  useEffect(() => {
    // After view switch, focus the cell closest to the previously focused date
    // or the first cell if no focused date
    // Use requestAnimationFrame to wait for the new view to render
    requestAnimationFrame(() => {
      const body = bodyRef.current;
      if (!body) return;

      // Find the element with tabIndex={0} (the roving tabindex target)
      const target = body.querySelector<HTMLElement>('[tabindex="0"]');
      if (target) {
        target.focus();
      }
    });
  }, [currentView]);
  ```
- Add `ref={bodyRef}` to the body container div.
- The `focusedDate` value is already used by the useRovingGrid hook in each view to determine `initialPosition`. So when a view mounts, it reads `focusedDate` from the store and positions `tabIndex={0}` on the nearest matching cell. The CalendarBody effect then focuses that element.

**Important coordination:**
- useRovingGrid (in each view) reads `focusedDate` from the store on mount to set `initialPosition`
- useKeyboard (in Calendar) handles T/D/W/M which call `setView`/`navigateDate` on the store
- CalendarBody detects `currentView` change and calls `.focus()` on the new view's `tabIndex={0}` element
- This three-part chain ensures: shortcut fires -> view changes -> new view renders with correct initial focus -> CalendarBody focuses that element

**Edge case:** If the calendar body has no focusable element (e.g., a view that doesn't have grid cells yet), the focus restoration is a no-op. This is fine.
  </action>
  <verify>
    Run `pnpm typecheck` -- no type errors.
    Run `pnpm lint` -- no lint violations.
    Run `pnpm test:ci` -- existing tests pass.
    Verify Calendar root div has `tabIndex={-1}` and `ref={rootRef}`.
    Verify CalendarBody has useEffect for focus restoration on view change.
    Verify useKeyboard is called in CalendarInner.
  </verify>
  <done>
    Calendar root is focusable (tabIndex={-1}) and wired with useKeyboard for T/D/W/M shortcuts and Escape handling. CalendarBody restores focus to the correct grid cell after view transitions using requestAnimationFrame. Full keyboard flow works: user presses D -> view switches to Day -> new view renders with tabIndex={0} on the nearest cell to previously focused date -> CalendarBody focuses that cell.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. `pnpm build` succeeds
4. `pnpm test:ci` passes
5. Calendar root has `tabIndex={-1}` (not in tab order but focusable)
6. Pressing T/D/W/M changes view (only when calendar is focused)
7. Escape cancels drag first, then clears selection
8. Shortcuts don't fire in INPUT/TEXTAREA/SELECT elements
9. Focus moves to correct cell after view switch
</verification>

<success_criteria>
- All keyboard shortcuts (T, D, W, M, Escape) work when calendar is focused
- Shortcuts are scoped -- they don't fire globally or in text inputs
- Escape respects the priority chain (drag > selection > nothing)
- View switching restores focus to the nearest matching cell in the new view
- Calendar root accepts keyboard focus for event bubbling
</success_criteria>

<output>
After completion, create `.planning/phases/04-keyboard-navigation-accessibility/04-03-SUMMARY.md`
</output>
