---
phase: 03-event-interactions
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - packages/core/src/components/DragLayer.tsx
  - packages/core/src/components/DragGhost.tsx
  - packages/core/src/components/DropIndicator.tsx
  - packages/core/src/components/SelectionOverlay.tsx
  - packages/core/src/views/week/TimeSlotColumn.tsx
  - packages/core/src/views/week/WeekView.tsx
  - packages/core/src/views/day/DayView.tsx
  - packages/core/src/components/CalendarBody.tsx
  - packages/core/src/components/Calendar.tsx
autonomous: true

must_haves:
  truths:
    - "During drag, a ghost event follows the cursor at fixed position with 0.85 opacity, and the original event at source shows reduced opacity (0.3)"
    - "During drag, a floating tooltip near the cursor displays the new start/end time in HH:mm format and the time delta from original"
    - "Drop validity is indicated by green (valid) or red (invalid) border color on the tooltip"
    - "User can click-drag on empty time slots to highlight a selection range, and releasing fires onSelect with start/end/allDay"
    - "Drag cancellation via Escape, tab-switch, blur, or right-click resets all visual feedback and drag state to idle"
    - "User can click an event (without exceeding threshold) and onEventClick fires with event data and native event"
  artifacts:
    - path: "packages/core/src/components/DragLayer.tsx"
      provides: "Portal container rendering DragGhost, tooltip, and DropIndicator"
      min_lines: 20
    - path: "packages/core/src/components/DragGhost.tsx"
      provides: "Ghost event element at fixed position"
      min_lines: 20
    - path: "packages/core/src/components/SelectionOverlay.tsx"
      provides: "Blue highlight rectangle for time range selection"
      min_lines: 20
    - path: "packages/core/src/views/week/TimeSlotColumn.tsx"
      provides: "TimeSlotColumn with drag/resize/select integration"
      contains: "useEventInteractions"
  key_links:
    - from: "packages/core/src/components/DragLayer.tsx"
      to: "packages/core/src/store/slices/interaction-slice.ts"
      via: "useCalendarStore selector for dragEngine state"
      pattern: "useCalendarStore.*dragEngine"
    - from: "packages/core/src/components/DragGhost.tsx"
      to: "packages/core/src/store/slices/interaction-slice.ts"
      via: "Reads dragEngine.origin and dragEngine.current for positioning"
      pattern: "dragEngine"
    - from: "packages/core/src/views/week/TimeSlotColumn.tsx"
      to: "packages/core/src/hooks/use-event-interactions.ts"
      via: "useEventInteractions hook for pointer event handlers"
      pattern: "useEventInteractions"
    - from: "packages/core/src/components/Calendar.tsx"
      to: "packages/core/src/components/DragLayer.tsx"
      via: "DragLayer rendered as sibling to CalendarBody"
      pattern: "DragLayer"
---

<objective>
Implement all visual feedback components (DragGhost, DragTimeTooltip, DropIndicator, SelectionOverlay), the DragLayer portal, slot selection on empty time slots, and wire all interactions into the time-grid views (TimeSlotColumn, WeekView, DayView, CalendarBody, Calendar).

Purpose: This plan completes Phase 3 by connecting the drag engine (Plan 02) to visible UI and integrating all interactions into the view rendering pipeline. After this plan, users can drag events, resize events, select time ranges, and click events with full visual feedback.
Output: Working drag/resize/select/click interactions in WeekView and DayView with ghost, tooltip, validity indicator, and selection overlay.
</objective>

<execution_context>
@/home/blacksilver/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/blacksilver/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-event-interactions/03-RESEARCH.md
@.planning/phases/03-event-interactions/03-01-SUMMARY.md
@.planning/phases/03-event-interactions/03-02-SUMMARY.md
@packages/core/src/types/interaction.ts
@packages/core/src/types/event.ts
@packages/core/src/store/slices/interaction-slice.ts
@packages/core/src/hooks/use-event-interactions.ts
@packages/core/src/hooks/use-drag.ts
@packages/core/src/hooks/use-selection.ts
@packages/core/src/components/EventBlock.tsx
@packages/core/src/components/DragLayer.tsx
@packages/core/src/components/DragGhost.tsx
@packages/core/src/components/SelectionOverlay.tsx
@packages/core/src/components/DropIndicator.tsx
@packages/core/src/components/CalendarBody.tsx
@packages/core/src/components/Calendar.tsx
@packages/core/src/views/week/TimeSlotColumn.tsx
@packages/core/src/views/week/WeekView.tsx
@packages/core/src/views/day/DayView.tsx
@packages/core/src/utils/snap.ts
@packages/core/src/utils/date-utils.ts
@packages/core/src/styles/calendar.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DragGhost, DragLayer with tooltip and validity indicator</name>
  <files>
    packages/core/src/components/DragGhost.tsx
    packages/core/src/components/DragLayer.tsx
    packages/core/src/components/DropIndicator.tsx
  </files>
  <action>
**DragGhost.tsx** -- Implement the ghost event that follows the cursor during drag.

Props: none -- it reads from Zustand store directly.

- Subscribe to `dragEngine` from the store using `useCalendarStore`
- Only render when `dragEngine.phase === 'dragging'` and `dragEngine.mode !== 'select'`
- Position at `position: fixed` using `dragEngine.current.x` and `dragEngine.current.y`
- Render a simplified version of the event content (title + time) inside the ghost div
- To get the event data: read events from `useCalendarConfig().events` and find by `dragEngine.origin.eventId`
- Apply CSS class `pro-calendr-react-drag-ghost`
- Style: `transform: translate(-50%, -20px)` to offset above the cursor, width ~200px (or match the original event width via origin.sourceElement.offsetWidth stored during startPending)
- The ghost should show the **new** snapped start/end times from `dragEngine.snappedStart` / `dragEngine.snappedEnd`

Actually, to avoid reading the entire events array, pass the event title and colors as part of the DragOrigin. But the current DragOrigin type doesn't have those. Two options:
1. Extend DragOrigin to include event title and colors
2. Find event from config.events

Option 2 is simpler and the events array is already in context. Use `useCalendarConfig().events.find(e => e.id === dragEngine.origin?.eventId)`.

Render content:
```tsx
<div className="pro-calendr-react-drag-ghost" style={{ left: x, top: y, ... }}>
  <div className="pro-calendr-react-event" style={{ backgroundColor, color, borderLeftColor, width, position: 'static' }}>
    <div className="pro-calendr-react-event-content">
      <span className="pro-calendr-react-event-time">{formatTime(snappedStart)} - {formatTime(snappedEnd)}</span>
      <span className="pro-calendr-react-event-title">{event.title}</span>
    </div>
  </div>
</div>
```

Use `formatTime` from `utils/date-utils` for the time display. Get `hour12` from `useCalendarConfig().hour12`.

**DragLayer.tsx** -- Portal container that renders DragGhost + tooltip + DropIndicator.

- Use `createPortal` to render into `document.body`
- Subscribe to `dragEngine.phase` only -- render nothing when idle
- When phase === 'dragging':
  - Render a div with class `pro-calendr-react-drag-layer`
  - Inside: `<DragGhost />` and the tooltip

- **Inline DragTimeTooltip** inside DragLayer (no separate component file needed -- it's small):
  - Position at `fixed` near the cursor: `left: current.x + 16, top: current.y - 16`
  - Show: `{formatTime(snappedStart)} - {formatTime(snappedEnd)}`
  - Show time delta: calculate difference between new start and original start, display as "+30min" or "-1h 30min"
  - Apply validity class: `pro-calendr-react-drag-tooltip--valid` or `pro-calendr-react-drag-tooltip--invalid`
  - If `validationMessage` exists, show it below the time

**DropIndicator.tsx** -- NOT rendered in the DragLayer (it needs to be positioned within the grid). Leave this as a simple component that renders a positioned highlight:

- Props: `{ top: number, height: number, isValid: boolean }`
- Renders a div with class `pro-calendr-react-drop-indicator` + `--valid` or `--invalid`
- This will be rendered inside TimeSlotColumn in Task 3

For this task, implement DropIndicator with props but it will be wired into TimeSlotColumn in Task 3.
  </action>
  <verify>
Run `pnpm typecheck` -- no errors. Run `pnpm lint` -- no errors. DragGhost, DragLayer, and DropIndicator compile without errors.
  </verify>
  <done>
DragGhost renders a fixed-position ghost event with snapped times during drag. DragLayer is a portal container with ghost + time tooltip showing new times, delta, and validity colors. DropIndicator renders a positioned validity highlight (valid=green, invalid=red). All components subscribe to dragEngine from Zustand store.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SelectionOverlay and slot selection pointer events</name>
  <files>
    packages/core/src/components/SelectionOverlay.tsx
    packages/core/src/hooks/use-selection.ts
  </files>
  <action>
**SelectionOverlay.tsx** -- Render the blue highlight rectangle during click-drag on empty time slots.

Props:
```typescript
interface SelectionOverlayProps {
  selection: { startY: number; endY: number } | null;  // pixel positions within the column
}
```

- When selection is null, render nothing
- Render a div with class `pro-calendr-react-selection-overlay`
- Style: `top: Math.min(startY, endY)`, `height: Math.abs(endY - startY)`, `left: 0`, `right: 0`
- The overlay is positioned absolutely within the TimeSlotColumn

**use-selection.ts** -- Enhance the existing useSelection hook to handle click-drag slot selection.

Add a new hook `useSlotSelection` (keep existing `useSelection` for backward compatibility):

```typescript
interface UseSlotSelectionOptions {
  containerRef: React.RefObject<HTMLElement>;
  day: Date;
  slotHeight: number;
  slotDuration: number;
  slotMinTime: string;
  slotMaxTime: string;
  totalSlots: number;
  selectable: boolean;
  onSelect?: (info: SelectInfo) => void;
}

interface SlotSelectionState {
  isSelecting: boolean;
  selectionPixels: { startY: number; endY: number } | null;
  handleSlotPointerDown: (e: React.PointerEvent) => void;
}
```

Implementation:
- On pointerdown on the column container (but NOT on an event -- check `e.target` to make sure it's the slot background or grid line, not an event block):
  - Guard: `if (!selectable || e.button !== 0) return;`
  - Set pointer capture on the column element
  - Record startY (clientY relative to container + scrollTop)
  - Set isSelecting = true
  - Start pending in the interaction slice with mode='select'

- On pointermove (while isSelecting):
  - Update endY based on current pointer position
  - This drives the SelectionOverlay height in real-time
  - Use a local `useState` for selectionPixels (NOT the Zustand store -- too expensive for pointermove)

- On pointerup:
  - If isSelecting:
    - Convert startY and endY to snapped times using `pointerToSnappedTime`-like logic (or directly: `slotIndex * slotDuration + gridStartMinutes`)
    - Ensure start < end (swap if needed)
    - Call `onSelect?.({ start: snappedStartDate, end: snappedEndDate, allDay: false })`
    - Also update the store's selection: `setSelection({ start: snappedStartDate, end: snappedEndDate })`
    - Reset isSelecting, clear selectionPixels
    - Call `completeDrag()` to reset the drag engine

- Apply same cancellation pattern: Escape, visibilitychange, blur cancel the selection.

Return: `{ isSelecting, selectionPixels, handleSlotPointerDown }`
  </action>
  <verify>
Run `pnpm typecheck` -- no errors. Run `pnpm lint` -- no errors.
  </verify>
  <done>
SelectionOverlay renders a blue highlight rectangle based on pixel coordinates. useSlotSelection handles click-drag on empty slots with pointer capture, converts pixel range to snapped time range, calls onSelect callback, and updates store selection. Cancellation via Escape/visibilitychange/blur supported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire all interactions into TimeSlotColumn, views, CalendarBody, and Calendar</name>
  <files>
    packages/core/src/views/week/TimeSlotColumn.tsx
    packages/core/src/views/week/WeekView.tsx
    packages/core/src/views/day/DayView.tsx
    packages/core/src/components/CalendarBody.tsx
    packages/core/src/components/Calendar.tsx
  </files>
  <action>
**TimeSlotColumn.tsx** -- This is the main integration point for time-grid interactions.

Add to TimeSlotColumnProps:
```typescript
editable?: boolean;
selectable?: boolean;
onEventDrop?: (info: EventDropInfo) => void;
onEventResize?: (info: EventResizeInfo) => void;
onSelect?: (info: SelectInfo) => void;
validateDrop?: CalendarProps['validateDrop'];
days: Date[];              // All visible days (for column detection in drag)
timeLabelsWidth: number;   // Width of time labels column
```

Inside the component:
1. Create a `ref` for the column container div
2. Call `useEventInteractions` with the container ref and all relevant props. Get back `handleEventPointerDown`.
3. Call `useSlotSelection` with the column ref, day, slot params, selectable, and onSelect. Get back `isSelecting`, `selectionPixels`, `handleSlotPointerDown`.
4. Read `dragEngine` from store to determine if we need to render a DropIndicator in this column.

Wire into the rendering:
- Pass `handleEventPointerDown` as `onPointerDown` to each `<EventBlock>`
- Pass `editable` and `durationEditable` props to each `<EventBlock>` (derive from the global `editable` prop and per-event overrides)
- Attach `handleSlotPointerDown` to the column container div's `onPointerDown` (this handles slot selection when the user clicks on empty space)
- Render `<SelectionOverlay selection={selectionPixels} />` inside the column
- Render `<DropIndicator>` inside the column when `dragEngine.phase === 'dragging'` and the drag target is this column's day (compare `dragEngine.snappedStart` day with `day`). Compute top/height from snappedStart/snappedEnd using the same pixel math as event positioning.

**WeekView.tsx** -- Pass new interaction props through to TimeSlotColumn:
- Accept `editable`, `selectable`, `onEventDrop`, `onEventResize`, `onSelect`, `validateDrop` on WeekViewProps
- Pass them through to each `<TimeSlotColumn>` along with `days` (the array of visible days) and `timeLabelsWidth` (use `var(--cal-time-label-width, 60)` -- just pass 60 as default or read from config)

**DayView.tsx** -- Same as WeekView: accept and pass interaction props to TimeSlotColumn. DayView has a single column so `days` is an array with one element.

**CalendarBody.tsx** -- The viewProps already include the callbacks from Plan 01 Task 3. Now also pass `editable`, `selectable`, `validateDrop` to viewProps (they're already on config). Make sure these are included in the spread to `<WeekView>` and `<DayView>`.

**Calendar.tsx** -- Render `<DragLayer />` as a sibling to `<CalendarBody />` inside the Calendar component. Import DragLayer and render it:
```tsx
<CalendarBody />
<DragLayer />
```

Also add `data-dragging` attribute management: the Calendar root div should get `data-dragging` when `dragEngine.phase === 'dragging'`. Read `dragEngine.phase` from store and conditionally apply: `data-dragging={phase === 'dragging' || undefined}`. This enables the `user-select: none` CSS rule.

**Important notes:**
- For the slot pointerdown handler on the column div: make sure it doesn't conflict with event pointerdown. The event's pointerdown calls `e.stopPropagation()` (in the EventBlock), so the column's pointerdown won't fire when clicking an event. Wait -- actually EventBlock's onPointerDown doesn't stopPropagation. We need to check `e.target`. In the slot selection handler: check if the click target is inside an event block (e.g., `(e.target as HTMLElement).closest('[data-event-id]')`). If so, don't start selection.
- The `timeLabelsWidth` is needed for `pointerToColumnIndex`. Use 60 as the default (matches `--cal-time-label-width`).
  </action>
  <verify>
1. `pnpm typecheck` -- no errors
2. `pnpm lint` -- no errors
3. `pnpm build` -- succeeds
4. `pnpm test` -- existing tests pass (check TimeSlotColumn, EventBlock, Calendar tests)
5. Manual verification via Storybook (if available): drag an event, see ghost + tooltip, resize handles visible on hover, click-drag on empty slot shows selection overlay
  </verify>
  <done>
TimeSlotColumn integrates useEventInteractions for drag/resize and useSlotSelection for slot selection. EventBlock receives onPointerDown/editable/durationEditable. SelectionOverlay and DropIndicator render inside TimeSlotColumn. DragLayer renders via portal in Calendar root. WeekView and DayView pass interaction props through. Calendar root has data-dragging attribute during active drag.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. `pnpm build` succeeds
4. `pnpm test` -- all existing tests pass
5. DragGhost renders at fixed position during drag (grep for `pro-calendr-react-drag-ghost` in DragGhost.tsx)
6. DragLayer uses createPortal (grep for `createPortal` in DragLayer.tsx)
7. SelectionOverlay renders selection rectangle (grep for `pro-calendr-react-selection-overlay` in SelectionOverlay.tsx)
8. TimeSlotColumn calls useEventInteractions (grep for `useEventInteractions` in TimeSlotColumn.tsx)
9. Calendar renders DragLayer (grep for `DragLayer` in Calendar.tsx)
10. EventBlock receives onPointerDown (grep for `onPointerDown` in TimeSlotColumn.tsx EventBlock usage)
</verification>

<success_criteria>
- DragGhost follows cursor during drag with semi-transparent appearance, showing snapped times
- Original event dims to 0.3 opacity during drag (via data-dragging attribute)
- Time tooltip shows new start/end time and delta, with green/red validity border
- SelectionOverlay renders blue highlight during slot click-drag
- onSelect fires with snapped start/end when slot selection completes
- DropIndicator shows green/red highlight at target position in the column
- onEventClick fires when clicking event without exceeding drag threshold
- onEventDrop fires on successful drag completion with new start/end
- onEventResize fires on successful resize completion with new start/end
- All cancellation events (Escape, blur, visibilitychange, contextmenu) reset drag state and visual feedback
- Calendar root has data-dragging during active drag (enables user-select: none CSS)
- Zero type errors, zero lint errors, zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-event-interactions/03-03-SUMMARY.md`
</output>
