---
phase: 03-event-interactions
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/core/src/hooks/use-drag.ts
  - packages/core/src/hooks/use-event-interactions.ts
  - packages/core/src/components/EventBlock.tsx
autonomous: true

must_haves:
  truths:
    - "EventBlock renders top and bottom resize handle divs when the event is editable and durationEditable"
    - "useEventInteractions hook provides pointerDown/Move/Up handlers that implement the idle->pending->dragging->idle state machine"
    - "Movement threshold (4px) correctly distinguishes click from drag -- pointerup during pending triggers onClick, not onDrop"
    - "During drag-move, snapped start/end times are computed from pointer position and written to the store only when they change"
    - "During resize, only the dragged edge (start or end) changes; the other edge stays fixed"
  artifacts:
    - path: "packages/core/src/hooks/use-event-interactions.ts"
      provides: "Main interaction orchestrator hook"
      exports: ["useEventInteractions"]
      min_lines: 80
    - path: "packages/core/src/components/EventBlock.tsx"
      provides: "EventBlock with resize handles and drag initiation"
      contains: "pro-calendr-react-event-resize-handle"
  key_links:
    - from: "packages/core/src/hooks/use-event-interactions.ts"
      to: "packages/core/src/store/slices/interaction-slice.ts"
      via: "useCalendarStore selectors for drag actions"
      pattern: "useCalendarStore.*startPending|startDragging|updateDragPosition"
    - from: "packages/core/src/hooks/use-event-interactions.ts"
      to: "packages/core/src/utils/snap.ts"
      via: "pointerToSnappedTime for coordinate conversion"
      pattern: "pointerToSnappedTime"
    - from: "packages/core/src/components/EventBlock.tsx"
      to: "packages/core/src/hooks/use-event-interactions.ts"
      via: "Resize handle onPointerDown callbacks"
      pattern: "onResizeStart|resize-handle"
---

<objective>
Build the core interaction engine hook (useEventInteractions) that manages the pointer event state machine for drag-to-move and drag-to-resize, and enhance EventBlock with resize handles and pointer event initiation.

Purpose: This hook is the behavioral core of all drag/resize interactions. It handles pointer capture, threshold detection, coordinate-to-time conversion, store updates at snapped boundaries, and drop validation. EventBlock gains resize handles that trigger resize mode.
Output: useEventInteractions hook, enhanced EventBlock with resize handles, useDrag updated for new API.
</objective>

<execution_context>
@/home/blacksilver/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/blacksilver/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-event-interactions/03-RESEARCH.md
@.planning/phases/03-event-interactions/03-01-SUMMARY.md
@packages/core/src/types/interaction.ts
@packages/core/src/types/event.ts
@packages/core/src/store/slices/interaction-slice.ts
@packages/core/src/hooks/use-drag.ts
@packages/core/src/components/EventBlock.tsx
@packages/core/src/components/CalendarProvider.tsx
@packages/core/src/utils/snap.ts
@packages/core/src/utils/slot.ts
@packages/core/src/utils/date-utils.ts
@packages/core/src/utils/event-position.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useEventInteractions hook with pointer event state machine</name>
  <files>
    packages/core/src/hooks/use-event-interactions.ts
  </files>
  <action>
Create a new hook `useEventInteractions` that is the central orchestrator for all pointer-based interactions on events (drag-move and drag-resize). This hook does NOT handle slot selection (that's Plan 03).

**Interface:**
```typescript
interface UseEventInteractionsOptions {
  containerRef: React.RefObject<HTMLElement>;  // The time-grid scrollable container
  days: Date[];                                // Array of visible days (columns)
  slotHeight: number;
  slotDuration: number;
  slotMinTime: string;
  slotMaxTime: string;
  totalSlots: number;
  timeLabelsWidth: number;                     // Width of the time labels column (px)
  editable: boolean;
  onEventClick?: (event: CalendarEvent, nativeEvent: React.MouseEvent) => void;
  onEventDrop?: (info: EventDropInfo) => void;
  onEventResize?: (info: EventResizeInfo) => void;
  validateDrop?: CalendarProps['validateDrop'];
}

interface EventInteractionHandlers {
  handleEventPointerDown: (e: React.PointerEvent, event: CalendarEvent, mode: DragMode) => void;
}
```

**Implementation details:**

1. **Refs for intermediate state:** Use `useRef` for:
   - `lastSnappedStartRef` / `lastSnappedEndRef` -- to avoid store updates when snapped position hasn't changed
   - `dragOriginRef` -- stores the DragOrigin during drag (avoids reading from store on every move)
   - `initialPointerRef` -- for threshold check
   - `dragModeRef` -- current drag mode
   - `eventRef` -- the CalendarEvent being dragged

2. **handleEventPointerDown(e, event, mode):**
   - Guard: `if (e.button !== 0) return;` (only primary button)
   - Guard: `if (!editable) return;`
   - Guard: For resize, check `event.durationEditable !== false` (defaults to true if editable is true and event doesn't explicitly opt out)
   - Call `e.preventDefault()` to prevent text selection
   - Call `(e.currentTarget as HTMLElement).setPointerCapture(e.pointerId)`
   - Store initial pointer position, event, mode in refs
   - Call `startPending(mode, { eventId: event.id, start: parseDate(event.start), end: parseDate(event.end), sourceElement: e.currentTarget as HTMLElement }, { x: e.clientX, y: e.clientY })`
   - Attach `pointermove` and `pointerup` handlers to the element (via the captured pointer)

3. **handlePointerMove (attached to element after capture):**
   - If phase is 'pending': check threshold via `exceedsThreshold({ x: e.clientX, y: e.clientY }, initialPointerRef.current, DRAG_THRESHOLD)`. If exceeded, call `startDragging()` and set `data-dragging` attribute on the calendar root element.
   - If phase is 'dragging':
     - Get container rect and scrollTop from containerRef
     - Determine which column (day) using `pointerToColumnIndex`
     - Get the target day from `days[columnIndex]`
     - Compute snapped time using `pointerToSnappedTime(e.clientY, containerRect, scrollTop, slotHeight, slotDuration, slotMinTime, totalSlots, targetDay)`
     - For mode 'move': compute newStart = snappedTime, newEnd = newStart + original duration
     - For mode 'resize-start': compute newStart = snappedTime, keep original end (clamp so newStart < originalEnd)
     - For mode 'resize-end': keep original start, compute newEnd = snappedTime + slotDuration (clamp so newEnd > originalStart)
     - Only update store if snappedStart or snappedEnd actually changed (compare with refs)
     - Run validateDrop if provided, get isValid + message
     - Call `updateDragPosition({ date: snappedTime, x: e.clientX, y: e.clientY }, newStart, newEnd, isValid, message)`
     - Update refs

4. **handlePointerUp:**
   - If phase is 'pending': treat as click. Call `onEventClick?.(event, nativeEvent)`. Call `cancelDrag()`.
   - If phase is 'dragging':
     - If isValid: for mode 'move', call `onEventDrop` with EventDropInfo (including a `revert` function that is a no-op since events are controlled). For mode 'resize-*', call `onEventResize` with EventResizeInfo.
     - Call `completeDrag()`
     - Remove `data-dragging` attribute from calendar root
   - Clean up: release pointer capture if still held, remove event listeners

5. **Cancellation listeners (useEffect when phase === 'dragging'):**
   - Listen on `document` for `visibilitychange`, `keydown` (Escape), `contextmenu`
   - Listen on `window` for `blur`
   - All trigger `cancelDrag()` + cleanup + remove `data-dragging` from root
   - Return cleanup function to remove listeners

6. **Return:** `{ handleEventPointerDown }`

**Performance:** The hook uses `useCalendarStore` with individual selectors for each action (startPending, startDragging, etc.) to avoid re-rendering on state changes that don't affect the hook's behavior. The pointer event handlers read from refs, not from React state, so they don't cause re-renders.

**Important:** Use `parseDate` from date-utils to convert event.start/end (which could be strings) to Date objects. Use `getMinutesSinceMidnight` and `differenceInMinutes` for duration calculations.
  </action>
  <verify>
Run `pnpm typecheck` -- no errors. Run `pnpm lint` -- no errors. The hook should compile and export `useEventInteractions`.
  </verify>
  <done>
useEventInteractions hook exists, exports handleEventPointerDown. Implements idle->pending->dragging->idle state machine with 4px threshold. Handles drag-move (both start and end shift), resize-start (only start changes), resize-end (only end changes). Validates drops when validateDrop provided. Cancellation listeners for Escape, visibilitychange, blur, contextmenu. Click-through when threshold not exceeded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add resize handles and pointer event initiation to EventBlock</name>
  <files>
    packages/core/src/components/EventBlock.tsx
  </files>
  <action>
Enhance EventBlock to render resize handles and accept pointer event callbacks for drag initiation.

**New props on EventBlockProps:**
```typescript
editable?: boolean;         // Whether drag-to-move is enabled
durationEditable?: boolean; // Whether resize handles appear (defaults to editable if not set)
onPointerDown?: (e: React.PointerEvent, event: CalendarEvent, mode: DragMode) => void;
```

Note: `DragMode` is imported from `../types/interaction`.

**Changes to EventBlock:**

1. Derive `canDrag` from: `editable && event.editable !== false` (per-event opt-out)
2. Derive `canResize` from: `canDrag && (durationEditable ?? true) && event.durationEditable !== false`

3. Add `onPointerDown` handler to the root div that calls `onPointerDown?.(e, event, 'move')` when `canDrag` is true. This initiates drag-to-move.

4. Remove or keep the existing `onClick` handler -- but be aware that the useEventInteractions hook now handles click-through via the pending->pointerup path. The existing `onClick` prop on EventBlock should still work for non-drag scenarios (e.g., MonthView events that don't have drag enabled yet). Keep `onClick` but add the `onPointerDown` as an additional handler.

5. Render resize handles when `canResize` is true. These are real DOM elements (NOT pseudo-elements):
```tsx
{canResize && (
  <>
    <div
      className="pro-calendr-react-event-resize-handle pro-calendr-react-event-resize-handle--top"
      onPointerDown={(e) => {
        e.stopPropagation(); // Don't trigger move drag on the parent
        onPointerDown?.(e, event, 'resize-start');
      }}
    />
    <div
      className="pro-calendr-react-event-resize-handle pro-calendr-react-event-resize-handle--bottom"
      onPointerDown={(e) => {
        e.stopPropagation(); // Don't trigger move drag on the parent
        onPointerDown?.(e, event, 'resize-end');
      }}
    />
  </>
)}
```

6. Update the `data-dragging` attribute: it already exists. No changes needed.

7. Add `data-editable={canDrag || undefined}` to the root div for CSS targeting (resize handle visibility).

8. Update the cursor: when `canDrag` is true, the root div should have `cursor: grab` in its inline styles (but only when not in a drag). This is better done via CSS: `.pro-calendr-react-event[data-editable] { cursor: grab; }` -- but that CSS is already in Plan 01's CSS additions. Just make sure the data attribute is set.

Actually, add this CSS rule to the CSS task in Plan 01 -- wait, Plan 01 is already created. Instead, just note that we need `.pro-calendr-react-event[data-editable] { cursor: grab; }` added to the CSS. Add it inline if the CSS from Plan 01 doesn't already include it. If not, add it at the end of the existing event block CSS section in calendar.css.
  </action>
  <verify>
Run `pnpm typecheck` -- no errors. Run `pnpm lint` -- no errors. Visually inspect EventBlock output: when editable=true, the root div has data-editable, and two resize handle divs are rendered inside it.
  </verify>
  <done>
EventBlock accepts onPointerDown, editable, durationEditable props. Renders resize handles (real divs) at top and bottom when canResize is true. Resize handle pointerdown events stopPropagation to prevent triggering move drag. data-editable attribute set for CSS cursor targeting. Existing onClick preserved for non-drag scenarios.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. `pnpm build` succeeds
4. `pnpm test` -- existing EventBlock tests pass (no regressions)
5. Grep for `useEventInteractions` in hooks/ returns the new file
6. Grep for `resize-handle` in EventBlock.tsx returns matches
7. Grep for `handleEventPointerDown` in use-event-interactions.ts returns a match
8. Grep for `exceedsThreshold` in use-event-interactions.ts confirms threshold check is implemented
9. Grep for `setPointerCapture` in use-event-interactions.ts confirms pointer capture pattern
</verification>

<success_criteria>
- useEventInteractions hook created with full pointer event state machine
- EventBlock renders resize handles when editable + durationEditable
- Movement threshold (4px) distinguishes click from drag
- Snap-to-grid during drag via pointerToSnappedTime
- Store only updated when snapped position actually changes (ref comparison)
- Cancellation listeners for Escape, visibilitychange, blur, contextmenu
- validateDrop integration during drag
- Click-through when threshold not exceeded (pending -> pointerup -> onClick)
- Zero type errors, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-event-interactions/03-02-SUMMARY.md`
</output>
